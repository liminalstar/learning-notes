# デジタル基礎2(初心者用)

## 第6章 応用構文を知ろう

前回、第5章で基本構文を学習しましたね。

今回は応用構文です。
まずは応用構文の表を上げます。

| 分野             | 内容                                    | 概要                     |
| -------------- | ------------------------------------- | ---------------------- |
| **例外処理**       | `try` / `except` / `finally` | エラーが発生したときの安全な処理方法     |
| **ファイル操作**     | `open()` / 読み書き    | テキストやCSVなどのファイルを読み書きする |
| **リスト内包表記**    | `[x for x in list if 条件]` | よりコンパクトにリストを生成         |
| **辞書操作**       | `.get()` / `.items()` / 内包表記          | キーと値のペアを使った柔軟な処理       |
| **クラス・オブジェクト** | `class` / `__init__()` / 継承           | オブジェクト指向による構造的プログラム設計  |
| **ラムダ式**       | `lambda`                              | 一時的な関数をその場で作成          |
| **デコレータ**      | `@decorator_name`                     | 関数に機能を後付けする            |
| **ジェネレータ**     | `yield`                               | 大きなデータを一部ずつ扱う仕組み       |
| **with構文**     | `with open() as f:`                   | リソース管理を簡単に安全にする構文      |
| **モジュールの利用**   | `import` / `from ... import`          | 他のファイル・ライブラリの再利用       |
| **標準ライブラリ活用**  | `datetime`, `os`, `math`, `random` など | よく使う便利なツール群の理解         |
| **再帰関数**       | 関数が自分を呼ぶ               | 数列や木構造のような問題に対応        |

さてまた色々でてきましたね！

覚えることが多くて頭い痛いかもしれませんが、一つ一つは単調な動作なので頑張ってイメージを作りましょう。

主要なものを個別に説明していきます。

### ■ ファイル操作

プログラムを通して、あなた(開発者)は様々なデータを読み書きしたりします。

一番身近なのが、ファイルですよね！

> ファイルを読み書きするための関数が open関数です。

どうやって書くのか例を紹介します。

```python
    # python
    # example_fileという名称のファイルを開きます。読み込みモードで(read:=r)
    f = open("example_file.txt", "r")  # ファイルの情報を変数fに入れます。(file:=f)
    txt = f.read() # fのテキスト情報を取得します。.read()
    f.close() # ファイルが開きっぱなしにならないように閉じる命令を入れます。
```

人が手で操作するのと変わりませんね！

ファイルを選択して -> 開いて -> 表示 -> 閉じる

これをプログラムで表現しているわけです。

下に、ファイルを操作する時のモード表を掲載します。

| モード    | 読み書き   | 説明                    | ファイルがない場合   | ファイルがある場合       |
| ------ | ------ | --------------------- | ----------- | --------------- |
| `'r'`  | 読み込み専用 | 既存のファイルを読み込む  | **エラー**になる  | 先頭から読み込み        |
| `'w'`  | 書き込み専用 | 内容を上書きする   | **新規作成**される | **中身が消える（上書き）** |
| `'a'`  | 追記専用   | ファイル末尾に追加  | **新規作成**される | 末尾に追記される        |
| `'r+'` | 読み書き両方 | 内容を読み書き    | **エラー**になる  | 読み・書きとも可能（上書き）  |
| `'w+'` | 読み書き両方 | 内容を削除して読み書き | **新規作成**される | **中身が消える（上書き）** |
| `'a+'` | 読み書き両方 | 読み込んだあと、**常に末尾に書き込む** | **新規作成**される | 末尾に追記される        |

### ■ with構文

with構文です。

簡単に言いますと。
> 記述を簡潔にして、エラーを防ぐようにするための関数です。

さて先ほど、ファイル操作を学習しましたね？

実際使ってみると分かるんですが、closeをよく忘れます..。

自動で処理が終わったら勝手にファイル閉じてくれる(リソース解放)方がうれしいですよね？

良かったですね。それがwithです。書き方は以下になります。

```python
    # python
    with open("example_file.txt", "r") as f: # with 開始する処理 as 変数:
        txt = f.read()  # 開始する処理の内容 処理が終わると自動でcloseします！
```

もちろん、ファイル操作以外でも使えますが、、データベース接続とか！

有効に使えれば安全なコードが書けますね！

### ■ 例外処理

例えば、あなたが作ったコードで思いもよらないデータが投入されてエラーが起こったとき。

処理の途中でも止められるようにしたいですよね？

電子レンジというツールに普段は入れないはずのたまごを入れてしまってスタートボタンを押してしまった！

爆発させる前に検知して止めたいですよね？

そのための構文例外処理です。

> なにか例外が起こったときに別の処理にジャンプするための構文が例外処理です。通称Try文とも言います。

書き方を説明します。

```python
    # python
    try:
        # 通常の処理を実行
        # ファイルを開きます。もし開くべきファイルがないとexceptに飛びます。
        with open("data.txt", "r") as f: 
            print(f.read())

    except FileNotFoundError as e:
        # 通常の処理で例外が発生したときにこちらに飛びます。
        print("filenotfound:", e)
    finally:
        # 通常に処理が終わっても、例外処理になっても必ず最後実行されます。
        print("処理を終了します。")
```

上記の動作例では、一度tryの中を実行します。実行途中でエラーがなければtryの最後まで行きます。

もし、エラーがtryの実行中にあるとただちにexceptionの例外処理に行きます。

最後finallyがtry, except関係なしに実行されるという中身となります。

exceptのErrorは複数種類がありますので、tryの中身に応じたエラーをキャッチできるものを選びましょう！

ちなみに、exceptは複数書けます。

### ■ リスト内包表記

> for文を使ってリストに入れる場合の書き方の簡潔版

こう書きます。

```python
    # python
    data = [ x for x in range(10)]

```

ちなみに普通のfor文で書くと以下になります。

```python
    # python
    data = []
    for x in range(10):
        data.append(x)
```

これを比較するとかなり簡潔になると思います。

もちろん条件分岐を入れた書き方もできます。

```python
    # python
    data = [x for x in range(10) if x % 2 == 0]
```

このように条件を書いて取得するものを限定できたりもできます。

元のコードがこちら

```python
    data = []
    for x in range(10):
        if x % 2 == 0:
            data.append(x)
```

覚えると楽に記述できるようになりますね！

### ラムダ式(無名関数)

> def関数の簡易版を作成できます。

先ほどの、リスト内包記と立ち位置が似ています。

書き方は以下

```python
    # python
    calc = lambda x, y : x + y # 引数x, yを用いて x + y を実行します。
    result = calc(x=2, y=3)
```

defの書き方にすると以下になります。

```python
    # python
    def calc(x, y): # 関数calc 引数は２つxとy
        return x + y
    result = calc(x=2, y=3)
```

ちょっとした処理とかには役立ちそうですね！

### ■ クラス・オブジェクト

> クラスは、属性とメソッドを管理をまとめるための記法です。

よくある話をします。

「みなさん、動物を思い浮かべてください」と言われたら何を思い浮かべますか？

蛇とか馬とかウサギとかそれぞれ色々考えると思います。

動物の定義は、「動いて生命活動を維持する」というものがあると思います。

上記のような定義のように、例えばどの動物関係なしに鳴き声はあると思います。

例えば、動物をプログラムで再現するときにそれぞれの鳴き声だったり、

種類だったりを作るのはかなり困難です。ですから

> あらかじめ、あるカテゴリでその振る舞いと情報をひとまとまりにするためのものがクラスです

では、動物を例にclassの例を記します。

```python
    # python
    class Animal:
        def __init__(self): # コンストラクタ　(クラスのインスタンス↓が生成される前に動く関数)
            self.name = None    # 動物名称
            self.animal_sound = None # 鳴き声
            self.staple_food = None # 主食
        
        def name_print(self): # クラス内で定義されるdef関数これによりクラス内で管理されます。
            print(self.name)
            
        def sound_print(self):
            print(self.animal_sound)
        
        
    if __name__ == "__main__": # 条件分岐： このファイルがmainで実行されている時に処理をする分岐
        ani = Animal() # クラスAnimal を変数ani に追加します。
        ani.name = "犬" # クラスで定義されている変数に値を追加します。
        ani.animal_sound = "わんわん" 
        ani.name_print() # クラス内で定義した関数を呼び出します。
        ani.sound_print() 
```

沢山書かれて理解が難しいですね、、。

Animalというクラスに犬の情報を覚えさせて、名前と鳴き声をそれぞれ出力させていますね！

クラスという集合体(オブジェクト)に関係する情報セットと関数が入るイメージです。

次に**継承**という手法を記します。

コードを見ながらしくみを理解しましょう。

```python
    # python
    class Animal:
        def __init__(self):
            self.name = None    # 動物名称
            self.animal_sound = None # 鳴き声
            self.staple_food = None # 主食
        
        def name_print(self): # クラス内で定義されるdef関数これによりクラス内で管理されます。
            print(self.name)
            
        def sound_print(self):
            print(self.animal_sound)
        
    class Dog(Animal): # 親クラスはAnimal
        def __init__(self):
            super().__init__() # 親クラスのコンストラクタを継承
            self.kenshu = None
        
        def kenshu_print(self):
            print(self.kenshu)
        
    if __name__ == "__main__": # 条件分岐： このファイルがmainで実行されている時に処理をする分岐
        ani = Dog()  # Dogクラス（Animalクラスを継承）からインスタンスを作成します。
        ani.name = "犬" # クラスで定義されている変数に値を追加します。
        ani.animal_sound = "わんわん"
        ani.kenshu = "柴犬" 
        ani.name_print() # クラス内で定義した関数を呼び出します。
        ani.sound_print() 
        ani.kenshu_print()
```

さてclassが１つ増えましたね！Dogというクラス名です。

犬の情報と関連する関数が登録されています。

ここまではAnimalというクラスと同じです。

1つ違うことがあります。以下になります。

```python
    class Dog(Animal): # Dogのクラス(子)にAnimal(親) のクラスを継承します。
        def __init__(self):
            super().__init__() # Dogのクラスに親のコンストラクタを継承します。
```

このように記入することで、

> 親となるクラスの関数と情報を使えるようになる！というしくみです。

だから継承と言います。

既にあるクラスを再利用して拡張できるというメリットがあります。

オブジェクト指向なプログラミングの一つですね！

### ■ モジュールの利用/標準ライブラリ

モジュールについて簡単に説明します。

> モジュールとは、特定の挙動をするスクリプトのまとまりでimport することで再利用できる！

モジュールの種類は以下です。

- 標準ライブラリ(最初から使える)
  - 例：os, math, datetime, sys など
- 外部ライブラリ(自分でインストールする)
  - 例：pandas, flask, numpy
- 自作モジュール(自分で作成した.pyファイル)
  - 他の.pyファイルをimport して使える

以下は、モジュール利用(標準ライブラリ)の例です。

```python
    # python
    import os  # 標準ライブラリ os を読み込む

    current_dir = os.getcwd()  # カレントディレクトリを取得
    print("現在のディレクトリ：", current_dir)

    files = os.listdir()  # 現在のディレクトリにあるファイル一覧を取得
    print("ファイル一覧：", files)
```

OSはファイルやディレクトリ、環境変数など「OS（オペレーティングシステム）」に関する操作を行うための標準ライブラリです。

このように既にある関数などをインポートして再利用できるんです！

便利なので是非活用していきましょう！

## 第7章 まとめ

この章で学んだのは「一歩進んだ書き方」ばかりですが、一つ一つはシンプルな機能です。まずは、よく使いそうなものから手を動かして試してみてください！

焦らずに、コードを読む・書くを繰り返せば、自然と身につきますよ！
